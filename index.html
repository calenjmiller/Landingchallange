<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1, user-scalable=no" />
  <title>Landing Challenge</title>
  <style>
    html, body { margin:0; height:100%; background:#0b1020; color:#e8eefc; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial; overscroll-behavior:none; }
    #wrap { display:flex; flex-direction:column; height:100%; }
    #topbar { padding:10px 12px; background:#111a33; border-bottom:1px solid rgba(255,255,255,.08); }
    #topbar b { color:#fff; }
    #hud { font-size:14px; line-height:1.35; opacity:.95; display:flex; gap:18px; flex-wrap:wrap; }
    #hud span { white-space:nowrap; }
    #hint { margin-top:6px; font-size:13px; opacity:.85; }
    canvas { width:100%; height:100%; display:block; touch-action:none; }

    #footer { padding:8px 12px; background:#111a33; border-top:1px solid rgba(255,255,255,.08); font-size:13px; opacity:.9;}

    .key { padding:1px 6px; border:1px solid rgba(255,255,255,.25); border-bottom-width:2px; border-radius:6px; margin:0 2px; }

    /* Mobile controls overlay */
    #touchControls {
      position: fixed;
      left: 0; right: 0; bottom: 0;
      padding: 10px 10px 14px;
      display: none; /* auto-enabled on touch devices */
      gap: 10px;
      align-items: flex-end;
      justify-content: space-between;
      pointer-events: none; /* children re-enable */
      z-index: 50;
    }
    #touchControls .panel {
      pointer-events: auto;
      background: rgba(17,26,51,0.72);
      border: 1px solid rgba(255,255,255,0.10);
      backdrop-filter: blur(8px);
      border-radius: 14px;
      padding: 10px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.35);
    }
    .btnGrid {
      display: grid;
      grid-template-columns: 64px 64px;
      grid-template-rows: 64px 64px;
      gap: 10px;
      place-items: stretch;
    }
    .btn {
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(255,255,255,0.10);
      color: #fff;
      border-radius: 16px;
      font-size: 14px;
      font-weight: 700;
      display:flex;
      align-items:center;
      justify-content:center;
      user-select: none;
      -webkit-user-select: none;
      touch-action: none;
    }
    .btn:active { transform: scale(0.98); background: rgba(255,255,255,0.16); }
    .smallBtnRow { display:flex; gap:10px; margin-top:10px; }
    .btnSmall {
      width: 138px;
      height: 44px;
      border-radius: 14px;
      font-size: 14px;
    }

    .throttleWrap {
      width: 170px;
    }
    .throttleWrap label {
      display:flex; justify-content:space-between; font-size:12px; opacity:.9; margin-bottom:8px;
    }
    input[type="range"]{
      width: 100%;
      accent-color: #7bd3ff;
    }

    /* Show touch controls on small screens or touch devices */
    @media (max-width: 920px) {
      #touchControls { display: flex; }
      #footer { padding-bottom: 90px; } /* leave room for controls */
    }
  </style>
</head>
<body>
<div id="wrap">
  <div id="topbar">
    <div><b>Landing Challenge</b> — touchdown zone + centerline + gentle sink rate.</div>
    <div id="hud"></div>
    <div id="hint">
      Keyboard:
      <span class="key">↑</span>/<span class="key">↓</span> pitch,
      <span class="key">←</span>/<span class="key">→</span> throttle,
      <span class="key">A</span>/<span class="key">D</span> rudder,
      <span class="key">R</span> restart
      <span style="opacity:.7">| Mobile: use buttons + throttle slider</span>
    </div>
  </div>

  <canvas id="c"></canvas>

  <div id="footer">
    Tip: Keep approach ~65–75 kt, small corrections, flare slightly just before touchdown.
  </div>
</div>

<!-- Touch Controls -->
<div id="touchControls">
  <!-- Left panel: pitch -->
  <div class="panel">
    <div style="font-weight:700; font-size:12px; opacity:.9; margin-bottom:8px;">PITCH</div>
    <div class="btnGrid">
      <div class="btn" id="btnPitchUp">↑<br><span style="font-size:11px; opacity:.85;">UP</span></div>
      <div class="btn" id="btnThrottleUp" style="display:none;"></div>
      <div class="btn" id="btnPitchDown">↓<br><span style="font-size:11px; opacity:.85;">DOWN</span></div>
      <div class="btn" id="btnThrottleDown" style="display:none;"></div>
    </div>
  </div>

  <!-- Middle panel: throttle -->
  <div class="panel throttleWrap">
    <label>
      <span style="font-weight:700;">THROTTLE</span>
      <span id="throttlePct">48%</span>
    </label>
    <input id="throttleSlider" type="range" min="0" max="100" value="48" />
    <div class="smallBtnRow">
      <div class="btn btnSmall" id="btnIdle">IDLE</div>
      <div class="btn btnSmall" id="btnMax">MAX</div>
    </div>
  </div>

  <!-- Right panel: rudder + restart -->
  <div class="panel">
    <div style="font-weight:700; font-size:12px; opacity:.9; margin-bottom:8px;">RUDDER</div>
    <div style="display:flex; gap:10px;">
      <div class="btn" style="width:74px; height:64px;" id="btnRudderL">A<br><span style="font-size:11px; opacity:.85;">LEFT</span></div>
      <div class="btn" style="width:74px; height:64px;" id="btnRudderR">D<br><span style="font-size:11px; opacity:.85;">RIGHT</span></div>
    </div>
    <div class="smallBtnRow">
      <div class="btn btnSmall" id="btnRestart">RESTART</div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const hud = document.getElementById('hud');

  // Prevent page scrolling while playing
  document.addEventListener('touchmove', (e) => { e.preventDefault(); }, { passive:false });

  // Resize
  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(canvas.clientWidth * dpr);
    const topH = document.getElementById('topbar').offsetHeight;
    const footH = document.getElementById('footer').offsetHeight;
    canvas.height = Math.floor((window.innerHeight - topH - footH) * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  window.addEventListener('resize', resize);

  const runway = {
    x: 0,
    width: 140,
    length: 2200,
    thresholdY: 0,
    touchdownZoneY: 320,
  };

  const plane = {
    x: 0,
    y: -1100,
    alt: 900,
    vx: 0,
    vy: 0,
    gs: 78,
    pitch: 0.02,
    throttle: 0.48,
    rudder: 0,
    onGround: false,
    crashed: false,
  };

  let env = { crosswindKt:0, windDir:0, gustKt:0, turbulence:0 };

  // Keyboard input
  const keys = new Set();
  window.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'r') reset();
    keys.add(e.key);
  });
  window.addEventListener('keyup', (e) => keys.delete(e.key));

  // Touch input states
  const touchState = {
    pitchUp:false, pitchDown:false,
    rudderL:false, rudderR:false,
  };

  // Helpers
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function lerp(a,b,t){ return a + (b-a)*t; }

  // Scoring
  let touchdown = null;
  let score = 0;

  // Touch controls elements
  const throttleSlider = document.getElementById('throttleSlider');
  const throttlePct = document.getElementById('throttlePct');

  function setThrottleFromUI(v01){
    plane.throttle = clamp(v01, 0, 1);
    const pct = Math.round(plane.throttle * 100);
    throttleSlider.value = String(pct);
    throttlePct.textContent = pct + '%';
  }

  throttleSlider.addEventListener('input', () => {
    setThrottleFromUI(parseInt(throttleSlider.value, 10) / 100);
  });

  document.getElementById('btnIdle').addEventListener('click', () => setThrottleFromUI(0));
  document.getElementById('btnMax').addEventListener('click', () => setThrottleFromUI(1));
  document.getElementById('btnRestart').addEventListener('click', () => reset());

  // Attach press-and-hold touch behavior
  function bindHoldButton(el, onDown, onUp){
    const start = (e) => { e.preventDefault(); onDown(); };
    const end = (e) => { e.preventDefault(); onUp(); };

    el.addEventListener('touchstart', start, { passive:false });
    el.addEventListener('touchend', end, { passive:false });
    el.addEventListener('touchcancel', end, { passive:false });

    // Also support mouse (desktop)
    el.addEventListener('mousedown', start);
    window.addEventListener('mouseup', end);
    el.addEventListener('mouseleave', end);
  }

  bindHoldButton(document.getElementById('btnPitchUp'),
    () => touchState.pitchUp = true,
    () => touchState.pitchUp = false
  );
  bindHoldButton(document.getElementById('btnPitchDown'),
    () => touchState.pitchDown = true,
    () => touchState.pitchDown = false
  );
  bindHoldButton(document.getElementById('btnRudderL'),
    () => touchState.rudderL = true,
    () => touchState.rudderL = false
  );
  bindHoldButton(document.getElementById('btnRudderR'),
    () => touchState.rudderR = true,
    () => touchState.rudderR = false
  );

  function reset() {
    touchdown = null; score = 0;

    plane.x = 0; plane.y = -1100; plane.alt = 900;
    plane.vx = 0; plane.vy = 0; plane.gs = 78;
    plane.pitch = 0.02; plane.rudder = 0;
    plane.onGround = false; plane.crashed = false;

    // Random wind
    const cw = (Math.random() * 16 - 8);
    env.crosswindKt = Math.round(cw);
    env.gustKt = Math.round(Math.random() * 6);
    env.turbulence = Math.random() * 0.7;
    env.windDir = 180 + Math.round(Math.random()*60 - 30);

    setThrottleFromUI(0.48);

    // Clear touch holds
    touchState.pitchUp = touchState.pitchDown = false;
    touchState.rudderL = touchState.rudderR = false;
  }

  function computeScore(t) {
    let s = 100;
    if (t.offRunway) return 0;

    const cx = Math.abs(t.x);
    s -= clamp((cx - 5) * 1.2, 0, 55);

    const dy = Math.abs(t.y - runway.touchdownZoneY);
    s -= clamp((dy - 80) * 0.05, 0, 35);

    const sp = t.gs;
    if (sp < 55) s -= (55 - sp) * 1.8;
    else if (sp > 85) s -= (sp - 85) * 1.4;
    else if (sp > 75) s -= (sp - 75) * 0.8;
    else if (sp < 65) s -= (65 - sp) * 0.8;

    const fpm = t.vs * 60;
    if (fpm > 600) s -= 55;
    else if (fpm > 360) s -= 30;
    else if (fpm > 180) s -= 12;

    if (t.hard) s -= 20;
    return Math.round(clamp(s, 0, 100));
  }

  let last = performance.now();
  function tick(now) {
    const dt = Math.min(0.033, (now - last) / 1000);
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(tick);
  }

  function update(dt) {
    // Merge keyboard + touch intentions
    const wantPitchUp = keys.has('ArrowUp') || touchState.pitchUp;
    const wantPitchDown = keys.has('ArrowDown') || touchState.pitchDown;

    const leftKey = keys.has('a') || keys.has('A');
    const rightKey = keys.has('d') || keys.has('D');
    const wantRudderL = leftKey || touchState.rudderL;
    const wantRudderR = rightKey || touchState.rudderR;

    if (!plane.onGround && !plane.crashed) {
      if (wantPitchUp) plane.pitch -= 0.12 * dt;
      if (wantPitchDown) plane.pitch += 0.12 * dt;
      plane.pitch = clamp(plane.pitch, -0.12, 0.14);

      // Keyboard throttle still works (touch slider overrides continuously)
      if (keys.has('ArrowLeft')) setThrottleFromUI(plane.throttle - 0.55 * dt);
      if (keys.has('ArrowRight')) setThrottleFromUI(plane.throttle + 0.55 * dt);

      const targetR = (wantRudderR ? 1 : 0) + (wantRudderL ? -1 : 0);
      plane.rudder = lerp(plane.rudder, targetR, 10 * dt);
    } else {
      plane.rudder = lerp(plane.rudder, 0, 5 * dt);
      setThrottleFromUI(lerp(plane.throttle, 0, 0.6 * dt));
    }

    const gust = env.gustKt ? (Math.sin(performance.now()/350) * env.gustKt) : 0;
    const crosswind = (env.crosswindKt + gust * 0.5);
    const turb = (Math.sin(performance.now()/120) + Math.sin(performance.now()/90)) * 0.5 * env.turbulence;

    const targetGs = 52 + plane.throttle * 55 - plane.pitch * 55;
    plane.gs = lerp(plane.gs, clamp(targetGs, 45, 105), 1.6 * dt);

    const baseSink = 13.0 - (plane.throttle * 7.0) + (plane.pitch * 95.0);
    const sink = baseSink + (plane.gs - 70) * 0.03;
    plane.vy = lerp(plane.vy, clamp(sink, -4.0, 24.0), 2.2 * dt);

    const ySpeed = plane.gs * 7.2;
    plane.y += ySpeed * dt;

    const rudderEffect = plane.rudder * 12.0;
    const lateralKt = crosswind - rudderEffect + turb * 0.6;
    plane.vx = lerp(plane.vx, lateralKt * 8.0, 2.0 * dt);
    plane.x += plane.vx * dt;

    plane.alt -= plane.vy * dt;
    if (plane.alt < 0) plane.alt = 0;

    if (!plane.onGround && !plane.crashed && plane.alt <= 0.01) {
      const withinRunwayX = Math.abs(plane.x - runway.x) <= runway.width / 2;
      const withinRunwayY = plane.y >= runway.thresholdY && plane.y <= runway.thresholdY + runway.length;

      const fpm = plane.vy * 60;
      const hard = fpm > 480;
      const offRunway = !(withinRunwayX && withinRunwayY);

      touchdown = { x: plane.x, y: plane.y, gs: plane.gs, vs: plane.vy, hard, offRunway };
      score = computeScore(touchdown);

      if (offRunway || fpm > 750) plane.crashed = true;
      else plane.onGround = true;
    }

    if (plane.onGround && touchdown) {
      plane.gs = lerp(plane.gs, 0, 0.55 * dt);
      plane.x += (plane.rudder * 55) * dt;
      plane.x = lerp(plane.x, plane.x * 0.995, 1);
      if (plane.gs < 3) plane.gs = 0;
    }
  }

  function draw() {
    const W = canvas.clientWidth;
    const H = canvas.clientHeight;
    ctx.clearRect(0, 0, W, H);

    const camY = plane.y - 280;
    const camX = 0;

    const g = ctx.createLinearGradient(0, 0, 0, H);
    g.addColorStop(0, '#06102a');
    g.addColorStop(1, '#0b1020');
    ctx.fillStyle = g;
    ctx.fillRect(0, 0, W, H);

    const runwayScreen = (x, y) => ({ x: W/2 + (x - camX), y: H - (y - camY) });

    const rTopLeft = runwayScreen(runway.x - runway.width/2, runway.thresholdY + runway.length);
    const rBottomLeft = runwayScreen(runway.x - runway.width/2, runway.thresholdY);
    const rW = runway.width;

    ctx.fillStyle = '#2b2f3a';
    ctx.beginPath();
    ctx.rect(rBottomLeft.x, rTopLeft.y, rW, rBottomLeft.y - rTopLeft.y);
    ctx.fill();

    ctx.strokeStyle = 'rgba(255,255,255,0.75)';
    ctx.lineWidth = 3;
    ctx.setLineDash([18, 18]);
    ctx.beginPath();
    const c1 = runwayScreen(runway.x, runway.thresholdY);
    const c2 = runwayScreen(runway.x, runway.thresholdY + runway.length);
    ctx.moveTo(c1.x, c1.y);
    ctx.lineTo(c2.x, c2.y);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = 'rgba(255,255,255,0.85)';
    for (let i = -3; i <= 3; i++) {
      if (i === 0) continue;
      ctx.fillRect(W/2 + i*18 - 6, runwayScreen(0, runway.thresholdY + 25).
